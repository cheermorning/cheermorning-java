## 设计模式学习

### 2021-04-09

1. 单一职责原则：每个类只负责一项职责

### 2021-04-10

1. 接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口之上
2. 依赖倒置原则：面向接口编程， 抽象不应该依赖细节，细节依赖抽象

### 2021-04-11

1. 里氏替换原则：正确使用继承，可以采用依赖、聚合、组合的方式解耦父子类关系
2. 开闭原则OCP: 对提供方扩展开放，对使用方修改关闭
3. 迪米特原则（最少知道原则）：目的是降低类之间的耦合度
4. 合成复用原则：在类定义变量或者方法时，尽量使用合成、聚合的方式，而不是使用继承

5. UML(统一建模语言), 类图：

   * class(类)
   * interface(接口)

   * 依赖(dependency)、
   * 泛化(generalization)、
   * 关联(association)、
   * 聚合(aggregation)、
   * 组合(composition)
   
6. 设计模式介绍

### 2021-04-14
1. 单例模式：八种
2. 简单工厂模式：多种功能类似的对象处理，定义一个创建对象的类，封装实例化对象的行为，

### 2021-04-15
1. 工厂方法模式：就是对简单工厂中的方法进行抽象，将对象的实例化推迟到子类处理

### 2021-04-20
1. 抽象工厂模式
2. 原型模式: bean.xml
3. 建造者模式： StringBuilder

### 2021-04-26
1. 适配器模式：
   * 类适配器模式，
   * 对象适配器模式：聚合关系代替继承关系，降低耦合
   * 接口适配器模式：
   
### 2021-04-28
1. 适配器模式：
   * 接口适配器模式：当不需要全部实现接口提供的方法是，可先设计一个抽象类实现接口，
     并为该接口中每一个方法提供一个默认实现（空方法）, 那么该抽象类的子类可有选择的覆盖父类的
     某些方法来实现需求
   * 源码分析：SpringMVC的HandleAdapter就符合接口适配器模式
      
### 2021-05-09
1. 桥接模式：Bridge
   * 案例 手机样式和手机品牌的处理
   * 桥接模式旨在替代多层继承的方案，减少类的个数
   * 桥接模式要求正确识别出系统中两个独立变化的维度，抽象与实现；
   * 应用场景：
     1. 银行转账：
        转账方式：手机转账、柜台转账、AMT转账---- 抽象
        转账用户：普通用户，银卡、金卡----实现
     2. 消息发送:
        消息类型：即时消息、延时消息----抽象
        消息方式：QQ消息、邮件消息、手机短信----实现
   * 源码分析：Driver驱动类。JDBC的驱动就是一个桥接模式。驱动管理为抽象。MySql/Oracle/SqlServer的驱动为实现
   
2. 装饰者模式：Decorator
   * 案例：咖啡订单，有不同的咖啡（被装饰者），和不同的调料（装饰者）
   * 满足OCP开闭原则
   * 装饰者模式就像一个打包的快递：有主体，有包装，分为装饰者和被装饰者
   * 源码分析：FilterInputStream 即继承了InputStream又组合了InputStream;

3. 组合模式：部分整体模式 Composite
   * 案例：大学、学院、系的组织架构展示问题
   * 组合方式通过继承+组合的方式处理树形结构的数据；
   
   * 源码分析：HashMap集合类，put和putAll就是一种组合模式
   
4. 外观模式: 过程模式Facade
   * 案例：家庭影院的一个启动关闭过程案例
   * 提供一个外观接口或者外观类，供调用者使用，不用关心里面的实现细节；定义一个高层接口，给子系统的接口提供一个统一的界面
   * 子系统分别组合到外观类中，并组成一个过程方法
   * 外观模式屏蔽的子系统的实现细节
   * 使用场景： 1. 需要分层设计时， 2，处理难以维护的遗留大型系统时
   * 源码分析：MyBatis的Configuration中的工厂类 new MeteObject()使用的就是外观模式
   
5. 享元模式： 蝇量模式 FlyWeight
   * 案例：网站内容分别以新闻、博客、公众号的形式展示
   * 享元模式就是利用共享技术有效的支持多个细粒度的对象;
   * 享元模式提出了两个要求：细粒度和共享对象，对象的信息分为内部状态ConcreteFlyWeight和外部状态NoSharedConcreteFlyWeight;
   * 内部状态：是对象共享出来的信息， 存储在享元对象中且不会随环境改变而改变;
   * 外部状态：对象依赖的一个标记信息，是随环境改变而改变的，不可共享的状态;
   * 享元模式可以解决重复对象的内存浪费现象，但是也提高了系统的复杂度
   * 源码分析：Integer valueOf() 就是一个享元模式
   * 应用场景：池技术， String常量池、数据库连接池、数据缓存池都是使用享元模式，享元模式是池技术的经典实现
   
   
### 2021-05-11 类图的六大关系

1. 类图的依赖关系Dependence
   * 类中使用到了对方
   * 类的成员属性
   * 方法中的返回类型
   * 方法中的参数类型
   * 方法中的使用到了对方
2. 类图的泛化关系（继承）Generalization
   * 依赖关系的特例
   * 泛化关系实际上就是继承关系
   * 如果A类继承了B类，那么A和B就是泛化关系
3. 类图的实现关系Implementation
   * 依赖关系的特例
   * 如果A类实现了B接口，那么A和B就是实现关系
   
4. 类图的关联关系Association
   * 依赖关系的特例
   * 关联关系具有导航性，单向和双向
   * 关联关系具有多重性，可以一对一，一对多，多对一
   * 人和身份证就是双向一对一关系
5. 类图的聚合关系Aggregation
   * 关联关系的特例
   * 具有关联关系的导航性和多重性
   * 整体与部分的关系，整体和部分可以分开；
   * 台式机：显示器、鼠标、键盘
```java
    public class Computer{
        private Mouse mouse;
        private Keyword keyword;
        private Monitor monitor;
}
```
6. 类图的组合关系Composition
   * 关联关系的特例
   * 具有关联关系的导航性和多重性
   * 整体与部分的关系，整体和部分不可以分开；
   * 笔记本电脑：显示器、键盘、触摸板
   * 如果两个类存在级联删除，那就是组合关系
```java
    public class Computer{
        private Mouse mouse = new Mouse();
        private Keyword keyword = new Keyword();
        private Monitor monitor = new Monitor();
}
```

7. 聚合和组合的案例：人和头是组合关系，不可以分开，分开人就死了；人和身份证是聚合关系，可以分开，人没身份证也可以或活着


8 代理模式 Proxy
  * 静态代理：代理对象和被代理对象都要实现同一个接口的方法，同时代理对象通过接口聚合被代理对象，实现调用被代理对象的方法
    1) 优点：在调用被代理对象的方法前，我们可以扩展一些方法
    2) 缺点：由于都要实现接口的方法，如果增加方法，代理对象和被代理对象都要维护，成本翻倍
    
  * 动态代理（JDK代理、接口代理）：代理对象不实现接口，通过反射机制Proxy.newProxyInstance()方法调用被代理对象的方法
  * Cglib代理（子类代理）: 目标对象没有接口，通过代理工厂实现cglib包中的MethodInterceptor#intercept方法，实现代理
    1) 源码分析：AOP面向切面编程就是一种Cglib代理模式. CglibAopProxy#processReturnType
    
### 2021-05-13

1. 模板方法模式: 模板模式
   * 就是在抽象类中，将一个流程固定下来，有的方法自己实现，有的方法子类重写
   * 钩子方法，在父类中定义一个方法，它默认不做任何事情，子类可以视情况要不要重写它。该方法称为“钩子”
   * 源码分析：Spring IOC的AbstractApplicationContext#refresh就是一个模板方法
   * 模板方法模式 实现了最大化代码复用；即统一了算法，也提供了很大的灵活性
   * 一般模板方法都会加上final关键字，防止子类重写模板方法；
   * 模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列步骤基本相同，
     但其个别步骤在实现时可能不同，通常可以考虑使用模板方法模式来处理；最好不同的情况少。种类也少
2. 命令模式：将军下达命令，士兵执行，中间靠命令传递作战
   * 源码分析：SpringJdbc中的JdbcTemplate的query方法
   * 应用场景：模拟CMD, 订单的撤销与恢复，触发-反馈机制
   
### 2021-05-25

1. 访问者模式：双分派
   * 如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，这时访问者模式是适合的。
   
2. 迭代器模式：解决统一遍历的问题
   * 源码分析：List接口就使用了iterator迭代器
   * 依赖系统接口Iterator
   * 解决统一遍历问题
   * 
3. 观察者模式：
   * 源码分析：Observable
   
### 2021-05-27

1. 中介者模式：实现松耦合，将网状关系分离成星状关系
  * 源码分析，MVC中 Controller就是 Model和View的中介者
  
2. 备忘录模式：游戏消耗后恢复到原状态

3. 解释器模式：Expression 正则表达式
  * 源码分析SpelExpressionParser
  * 应用场景：编译器、正则表达式、运算表达式、机器人
  * 解释器模式处理的问题本身就复杂, 因为采用递归调用方法

### 2021-05-29

1. 状态模式：
  * APP抽奖活动案例：奖品状态，以及动作状态；
  * 应用场景：当一个时间或者对象有很多种状态，状态之间会相互转换，对不同的状态要求有不同的行为的时候
    ，可以考虑使用状态模式， 多见于流程系列。

2. 策略模式：
  * 鸭子问题：
    - 鸭子种类：野鸭、北京鸭、玩具鸭；是不变的部分
    - 鸭子行为：叫、游泳、飞翔；是变化的部分
  * 策略模式的关键是：分析项目中的变化部分与不变部分
  * 策略模式的核心思想是：多用组合/聚合，少用继承；用行为类组合，而不是行为继承，
  * 体现了 对修改关闭、对扩展开发的原则，可以替换ifelse语句（多重转移语句）
  * 缺点：每添加一个策略，就需要添加一个类；策略过多会造成项目庞大；所以要区分请策略中变化部分；

3. 职责链（责任链）模式：

  * OA系统单据审批问题
  * 源码分析：SpringMVC的DispatchServlet类中的dsDispatch方法, HandlerExecutionChain类为职责链模式
  * 将请求与处理分开，实现解耦，提高系统灵活性
  * 简化了对象，使对象不需要知道链的接口
  * 性能会受到影响，尤其在链特别长的时候，一般通过在Handler中设置一个最大节点数量，一旦超过阈值，就不允许链的建立。
  * 使用场景: 有多个对象处理一个请求时， 比如：OA单据审批， Java Web中 Tomcat对Encoding的处理，拦截器
  